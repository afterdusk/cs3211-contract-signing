//The message endcoding for P1
#define P1PROMISE 1;
#define P1SIGN 3;
#define P1SECRET 1234;

//The message encoding for P2
#define P2PROMISE 2;
#define P2SIGN 4;
#define TIMEOUT 10;
#define P2SECRET 4321;

//The message encoding for TrustedParty
#define ABORT 1;
#define RESOLVE2 2;
#define RESOLVE1 3;

channel P1toP2 0;
channel P2toP1 0;
channel ToTrusted 0;

var empty = -1;

P1Start = P1toP2!P1PROMISE -> P1Next0;
P1Next0 = P2toP1?P2PROMISE -> P1Next1 timeout[5] P1Abort;

//if P1 does not receive p2's promise 
P1Abort = ToTrusted!ABORT.P1PROMISE.empty ->P1End;

P1End = Skip;


P2Start = P1toP2?P1PROMISE -> P2Next0 timeout[5] P2End;

P2End = Skip;

P2Next0 = P2toP1!P2PROMISE -> P2Next1;

TrustedParty = ToTrusted?Command.Message1.Message2 -> atomic{{M1=Message1->M2=Message2}->Skip};
//TrustedParty = ToTrusted?Command.Message1.Message2 -> atomic{{if(Command==ABORT){M1=Message1 -> Skip;} else {Skip;}};

/*
//Start of P1
P1Start = P1toP2! P1PROMISE->P1Next0; 
P1Next0 = (P2toP1?P2PROMISE->P1Next1) timeout[10]P1Abort;

//If P1 does not receive P2PROMISE, P1Abort is carried out. 
P1Abort = ToTrusted!P1ABORT.P1PROMISE ->Skip;

P1Next1 = atomic{{p1ReceivePromise = true}->P1toP2!P1SIGN->P1Next2};
P1Next2 = P2toP1?P2SIGN-> atomic{{p1ReceiveSign =true}->Skip};


//Start of P2
P2Start = (P1toP2?P1PROMISE->P2Next0) timeout[10] Skip;
P2Next0 = {p2ReceivePromise=true}->P2toP1!P2PROMISE->P2Next1;
P2Next1 = P1toP2?P1SIGN -> atomic{{p2ReceiveSign = true}->P2toP1!P2SIGN->Skip};

//Start of TrustedParty
TrustedParty = ToTrusted?Command.Message->atomic{if(Command==P1ABORT){p1abort = true} else {Skip;}};
*/


//assertions
System = P1Start|||P2Start|||TrustedParty;

#assert System deadlockfree;
//TODO: Write assert that if P2Start then P2Next0 or terminate within 10

#define test1(potato==actual);
#assert System reaches test1;