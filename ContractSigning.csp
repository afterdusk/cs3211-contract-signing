#import "PAT.Math";

// State
#define SENDPROMISE 1;
#define RECPROMISE 2;
#define SENDSIGN 3;
#define RECSIGN 4;
#define END 5;


// Contract ID
#define CONTRACT 11;

// P1 keys
#define P1PUBLIC 7;
#define P1PRIVATE 7;
#define P1MOD 21;

// P2 keys
#define P2PUBLIC 5;
#define P2PRIVATE 5;
#define P2MOD 14;

// Trusted party keys
#define TRUSTPUBLIC 3;
#define TRUSTPRIVATE 3;
#define TRUSTMOD 15;

// Trusted party states
#define EMPTY -1;
#define ABORT -2;
#define RESOLVE2 -3;
#define RESOLVE1 -4;

// Current states
var P1State = SENDPROMISE;
var P2State = RECPROMISE;

// P1
var recContractP2 = EMPTY;
var recPromiseP2 = EMPTY;
var recSignedP2 = EMPTY;
var P1Promise;
var P1Signature;
var P1TrustedConfirmation;

// P2
var recContractP1 = EMPTY;
var recPromiseP1 = EMPTY;
var recSignedP1 = EMPTY;
var P2Promise;
var P2Signature;
var P2TrustedConfirmation;

// Channel declaration
channel P1TOP2 10;
channel P2TOP1 10;
channel ToTrusted 10;
channel TrustedToP1 10;
channel TrustedToP2 10;

//TODO: Add attacker. 
//TODO: Add (NotOkay) channel inputs. 

P1 =
[P1State == SENDPROMISE] P1SendPromise 
[]
[P1State == RECPROMISE] P1ReceivePromise
[]
[P1State == SENDSIGN]P1SendSign 
[]
[P1State == RECSIGN]P1ReceiveSign
[]
[P1State == END]Skip;

P1SendPromise = generate{P1Promise=call(Pow,P1PRIVATE,TRUSTPUBLIC)%TRUSTMOD} 
	->P1TOP2!CONTRACT.P1Promise
	->setState{P1State=RECPROMISE}
	->P1
[]
P1TOP2!EMPTY.EMPTY 
	->setState{P1State=END} 
	->P1;

P1ReceivePromise = P2TOP1?placeholder0.placeholder1 
	-> P1ReceivePromiseAction(placeholder0,placeholder1);

//abort
P1ReceivePromiseAction(placeholder0,placeholder1) =
	if(placeholder0==EMPTY||placeholder0!=CONTRACT)
		{
			ToTrusted!ABORT.P1Promise.EMPTY.CONTRACT
			->TrustedToP1?placeholder0
			->setValues{P1TrustedConfirmation=placeholder0;}
			->setState{P1State=END}
			->P1
		}
	else 
		{
			storeValue{recContractP2=placeholder0;recPromiseP2=placeholder1;}
			->setState{P1State=SENDSIGN}
			->P1
		};
 

P1SendSign = generate{P1Signature=call(Pow,CONTRACT,P1PRIVATE)%P1MOD}
	->P1TOP2!P1Signature.EMPTY
	->setState{P1State = RECSIGN}
	->P1
[]
P1TOP2!EMPTY.EMPTY
	->setState{P1State = END} 
	->P1;

P1ReceiveSign = P2TOP1?placeholder0.placeholder1-> P1ReceiveSignAction(placeholder0);
//resolve1
P1ReceiveSignAction(placeholder0) =
	if(placeholder0==EMPTY||(call(Pow, placeholder0, P2PUBLIC)%P2MOD)!=CONTRACT)
	{
		generate{P1Signature=call(Pow, CONTRACT, P1PRIVATE)%P1MOD;}
		->ToTrusted!RESOLVE1.P1Signature.recPromiseP2.CONTRACT
		->TrustedToP1?placeholder0 
		->setValues{P1TrustedConfirmation = placeholder0;}
		->getP2Sign{var P1PlusP2=call(Pow, P1TrustedConfirmation,TRUSTPUBLIC)%TRUSTMOD;recSignedP2=P1PlusP2-P1Signature;}
		->setState{P1State = END}
		->P1
	}
	else
	{
		storeValue{recSignedP2=placeholder0}
		->setState{P1State = END}
		->P1
	};

P2 = 
[P2State == RECPROMISE]P2ReceivePromise
[]
[P2State == SENDPROMISE]P2SendPromise
[]
[P2State == RECSIGN]P2ReceiveSignature
[]
[P2State == SENDSIGN]P2SendSign
[]
[P2State == END]Skip;

P2ReceivePromise = P1TOP2?placeholder0.placeholder1 -> P2ReceivePromiseAction(placeholder0,placeholder1);

P2ReceivePromiseAction(placeholder0,placeholder1) = 
	if(placeholder0==EMPTY||placeholder0!=CONTRACT)
	{
		setState{P2State= END} 
		->P2
	}
	else 
	{
		storeValue{recContractP1=placeholder0;recPromiseP1=placeholder1;}
		->setState{P2State=SENDPROMISE}
		->P2
	};

P2SendPromise = generate{P2Promise=call(Pow, P2PRIVATE, TRUSTPUBLIC)%TRUSTMOD}->P2TOP1!CONTRACT.P2Promise->setState{P2State=RECSIGN}->P2
[]
P2TOP1!EMPTY.EMPTY->setState{P2State = END}->P2;

P2ReceiveSignature = P1TOP2?placeholder0.placeholder1-> P2ReceiveSignatureAction(placeholder0);
//resolve2
P2ReceiveSignatureAction(placeholder0)=
	if(placeholder0==EMPTY||call(Pow, placeholder0, P1PUBLIC)%P1MOD!=CONTRACT)
	{
		generate{P2Signature=call(Pow, CONTRACT, P2PRIVATE)%P2MOD}
		->ToTrusted!RESOLVE2.P2Signature.recPromiseP1.CONTRACT
		->TrustedToP2?placeholder0
		->setValues{P2TrustedConfirmation=placeholder0}
		->getP1Sign{var P1PlusP2=call(Pow, P2TrustedConfirmation, TRUSTPUBLIC)%TRUSTMOD;recSignedP1=P1PlusP2-P2Signature}
		->setState{P2State=END}
		->P2
	}
	else 
	{
		storeValue{recSignedP1=placeholder0}
		->setState{P2State=SENDSIGN}
		->P2
	};
	
P2SendSign = generate{P2Signature=call(Pow, CONTRACT, P2PRIVATE)%P2MOD}
	->P2TOP1!P2Signature.EMPTY
	->setState{P2State=END}
	->P2
[]
P2TOP1!EMPTY.EMPTY
	->setState{P2State=END}
	->P2;

var status = 0;
var trustedContract;
var trustedP1Promise;
var trustedP2Promise;
var trustedP1Sign;
var trustedP2Sign;
var confirmation;

TrustedParty = ToTrusted?request.field1.field2.field3-> TrustedPartyActions(request,field1,field2,field3);

TrustedPartyActions(request,field1,field2,field3) = 
	if(request==ABORT)
		{
			setValues{status=ABORT;trustedP1Promise=field1;trustedContract=field3}
			->generate{confirmation= call(Pow, trustedP1Promise, TRUSTPRIVATE)%TRUSTMOD}
			->TrustedToP1!confirmation
			->TrustedParty
		}
	else if(request==RESOLVE2&&status!=ABORT)
	{
		setValues{status=RESOLVE2;trustedP2Sign=field1;trustedP1Promise=field2;trustedContract=field3}
		->generate{var p1Secret=call(Pow, trustedP1Promise, TRUSTPRIVATE)%TRUSTMOD;var generatedSign=call(Pow, trustedContract, p1Secret)%P1MOD;confirmation=call(Pow, (generatedSign+trustedP2Sign), TRUSTPRIVATE)%TRUSTMOD;}
		->TrustedToP2!confirmation
		->TrustedParty
	}
	else if(request==RESOLVE1)
	{
		setValues{status=RESOLVE1;trustedP1Sign=field1;trustedP2Promise=field2;trustedContract=field3}
		->generate{var p2Secret=call(Pow, trustedP2Promise, TRUSTPRIVATE)%TRUSTMOD;var generatedSign=call(Pow, trustedContract, p2Secret)%P2MOD;confirmation=call(Pow, (generatedSign+trustedP1Sign), TRUSTPRIVATE)%TRUSTMOD;}
		->TrustedToP1!confirmation
		->TrustedParty
	};

/*
[request==ABORT]setValues{status=ABORT;trustedP1Promise=field1;trustedContract=field3}->generate{confirmation= trustedP1Promise^TRUSTPRIVATE%TRUSTMOD}->TrustedToP1!confirmation->TrustedParty
[]
[request==RESOLVE2&&status!=ABORT]setValues{status=RESOLVE2;trustedP2Sign=field1;trustedP1Promise=field2;trustedContract=field3}
->generate{p1Secret=trustedP1Promise^TRUSTPRIVATE%TRUSTMOD;generatedSign=trustedContract^p1Secret%P1MOD;confirmation=(generatedSign+trustedP2Sign)^TRUSTPRIVATE%TRUSTMOD;}
->TrustedToP2!confirmation->TrustedParty
[]
[request==RESOLVE1]setValues{status=RESOLVE1;trustedP1Sign=field1;trustedP2Promise=field2;trustedContract=field3}
->generate{p2Secret=trustedP2Promise^TRUSTPRIVATE%TRUSTMOD;generatedSign=trustedContract^p2Secret%P2MOD;confirmation=(generatedSign+trustedP1Sign)^TRUSTPRIVATE%TRUSTMOD;}
->TrustedToP1!confirmation->TrustedParty;
*/

System = P1|||P2|||TrustedParty;

#assert System deadlockfree;
