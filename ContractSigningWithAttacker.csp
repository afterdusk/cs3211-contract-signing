#import "PAT.Math";

// State endcodings NOTE: Will not be used in channel encodings
#define GENERATE 0;
#define SENDPROMISE 1;
#define RECPROMISE 2;
#define SENDSIGN 3;
#define RECSIGN 4;
#define END 5;

// Contract ID
#define CONTRACT 11;

// P1 keys
#define P1PUBLIC 7;
#define P1PRIVATE 7;
#define P1MOD 21;

// P2 keys
#define P2PUBLIC 5;
#define P2PRIVATE 5;
#define P2MOD 14;

// Trusted party keys
#define TRUSTPUBLIC 3;
#define TRUSTPRIVATE 3;
#define TRUSTMOD 15;

	// Encoded data values
#define EMPTY -1;
	//Encoded message types
#define PROMISETYPE -2;
#define SIGNTYPE -3;
#define ABORTTYPE -4;
#define RESOLVE1TYPE -5;
#define RESOLVE2TYPE -6;
#define ABORTCONFIRMATION -7;
#define RESOLVECONFIRMATION -8;

	//Encoded Identities
#define P1IP 1;
#define P2IP 2;
#define TRUSTEDIP 3;

// StartStates
var p1State = GENERATE;
var p2State = GENERATE;

// P1
var p1RecPromise = EMPTY;
var p1RecSign = EMPTY;
var p1Promise;
var p1Signature;
var p1TrustedConfirmation=EMPTY;

// P2
var p2RecPromise = EMPTY;
var p2RecSign = EMPTY;
var p2Promise;
var p2Signature;
var p2TrustedConfirmation=EMPTY;

// Channel declaration
channel p1ToRouter 10;
channel p2ToRouter 10;
channel routerToP1 10;
channel routerToP2 10;
channel trustedToRouter 10;
channel routerToTrusted 10;

//Message encoding style

// TODO: Put Contract in data1, always
// TODO: Write the format for TrustedParty originated messages

/*
	Msgtype:	Promise		Sign		Abort		Resolve1		Resolve2
	field 1:	Source IP(always)------------------------------------------------ 		
	field 2:	Dest Ip(always)--------------------------------------------------	
	field 3:	Msg Type(always)-------------------------------------------------
	field 4:	Promise		Signature	P1Promise	P1Sign			P2Sign
	field 5:	EMPTY		EMPTY		EMPTY		p1RecPromise	p2RecPromise
	field 6:	CONTRACT	EMPTY		CONTRACT	CONTRACT		CONTRACT
*/


//Start of P1

P1() =
	[p1State == GENERATE]P1GenerateValues()
	[]
	[p1State == SENDPROMISE]P1SendPromise()
	[]
	[p1State == RECPROMISE]P1ReceivePromise()
	[]
	[p1State == SENDSIGN]P1SendSign()
	[]
	[p1State == RECSIGN]P1ReceiveSign()
	[]
	[p1State == END]Skip;

P1GenerateValues() = 
	p1GeneratePromise{p1Promise = call(Pow, P1PRIVATE, TRUSTPUBLIC) % TRUSTMOD}
	-> p1GenerateSignature{p1Signature = call(Pow, CONTRACT, P1PRIVATE) % P1MOD}
	-> tau{p1State = SENDPROMISE}
	-> P1();
	
P1SendPromise() =
	p1ToRouter!P1IP.P2IP.PROMISETYPE.p1Promise.EMPTY.CONTRACT
	-> tau{p1State = RECPROMISE}
	-> P1()
	[]
	p1ToRouter!P1IP.P2IP.PROMISETYPE.EMPTY.EMPTY.EMPTY
	-> p1Terminate{p1State = END}
	-> P1();
	
P1ReceivePromise() = routerToP1?src.dest.msgtype.data1.data2.ct -> P1ReceivePromiseAction(src, dest, msgtype, data1, data2, ct);

P1ReceivePromiseAction(src, dest, msgtype, data1, data2, ct) =
	if (msgtype != PROMISETYPE || ct != CONTRACT || data1 == EMPTY)
	{
		// send abort if invalid promise received
		p1ToRouter!P1IP.TRUSTEDIP.ABORTTYPE.p1Promise.EMPTY.CONTRACT
		// receive abort confirmation from trusted party
		-> routerToP1?f1.f2.f3.f4.f5.f6
		// validate abort confirmation
		-> P1ReceiveTrustedAbortConfirmation(f1, f2, f3, f4, f5, f6)
	}
	else
	{
		p1StoreReceivedPromise{p1RecPromise=data1}
		-> tau{p1State = SENDSIGN}
		-> P1()
	};
	
P1ReceiveTrustedAbortConfirmation(src, dest, msgtype, data1, data2, ct) =
	if (msgtype == RESOLVECONFIRMATION)
	{
		// TODO: Run assertion to check for P2SIGN
		p1AbortFail{p1State = END}
		-> P1()
	}
	else if (msgtype == ABORTCONFIRMATION)
	{
		// TODO: Why save data1?
		p1StoreAbortConfirmation{p1TrustedConfirmation = data1} 
		-> tau{p1State = END}
		-> P1()
	};
	
P1SendSign() =
	p1ToRouter!P1IP.P2IP.SIGNTYPE.p1Signature.EMPTY.CONTRACT
	-> p1SendSign{p1State = RECSIGN}
	-> P1()
	[]
	p1ToRouter!P1IP.P2IP.SIGNTYPE.EMPTY.EMPTY.EMPTY
	-> p1Terminate{p1State=END}
	-> P1();

P1ReceiveSign() = routerToP1?src.dest.msgtype.data1.data2.ct -> P1ReceiveSignAction(src, dest, msgtype, data1, data2, ct);

P1ReceiveSignAction(src, dest, msgtype, data1, data2, ct)=
	if (msgtype != SIGNTYPE || ct != CONTRACT || data1 == EMPTY || call(Pow, data1, P2PUBLIC) % P2MOD != CONTRACT)
	{
		// send resolve1 if invalid sign received
		p1ToRouter!P1IP.TRUSTEDIP.RESOLVE1TYPE.p1Signature.p1RecPromise.CONTRACT
		// receive resolve1 confirmation from trusted party
		-> routerToP1?f1.f2.f3.f4.f5.f6
		// validate resolve1 confirmation
		-> P1ReceiveTrustedResolve1Confirmation(f1, f2, f3, f4, f5, f6)
	}
	else
	{
		p1StoreReceivedSign{p1RecSign = data1}
		-> tau{p1State = END}
		-> P1()
	};
	
P1ReceiveTrustedResolve1Confirmation(src, dest, msgtype, data1, data2, ct) =
	if (msgtype == ABORTCONFIRMATION)
	{
		// TODO: Run assertion here?
		resolve1Fail{p1State = END}
		-> P1()
	}
	else if (msgtype == RESOLVECONFIRMATION)
	{
		p1StoreResolve1Confirmation{p1TrustedConfirmation = data1}
		-> p1GetP2Sign{var p1PlusP2 = call(Pow, p1TrustedConfirmation, TRUSTPUBLIC) % TRUSTMOD; p1RecSign = p1PlusP2 - p1Signature}
		-> tau{p1State = END}
		-> P1()
	};


//Start of P2
	
P2() = 
	[p2State == GENERATE]P2GenerateValues()
	[]
	[p2State == RECPROMISE]P2ReceivePromise()
	[]
	[p2State == SENDPROMISE]P2SendPromise()
	[]
	[p2State == RECSIGN]P2ReceiveSign()
	[]
	[p2State == SENDSIGN]P2SendSign()
	[]
	[p2State == END]Skip;

P2GenerateValues() =
	p2GeneratePromise{p2Promise = call(Pow,P2PRIVATE,TRUSTPUBLIC) % TRUSTMOD}
	-> p2GenerateSignature{p2Signature = call(Pow,CONTRACT,P2PRIVATE) % P2MOD}
	-> tau{p2State = RECPROMISE}
	-> P2();
	
P2ReceivePromise() = routerToP2?src.dest.msgtype.data1.data2.ct -> P2ReceivePromiseAction(src, dest, msgtype, data1, data2, ct);

P2ReceivePromiseAction(src, dest, msgtype, data1, data2, ct) =
	if(msgtype != PROMISETYPE || ct != CONTRACT || data1 == EMPTY)
	{
		p2Terminate{p2State = END}
		-> P2()
	}
	else
	{
		p2StoreReceivedPromise{p2RecPromise = data1}
		-> tau{p2State = SENDPROMISE}
		-> P2()
	};
	
P2SendPromise() = 
	p2ToRouter!P2IP.P1IP.PROMISETYPE.p2Promise.EMPTY.CONTRACT
	-> tau{p2State = RECSIGN}
	-> P2()
	[]
	p2ToRouter!P2IP.P1IP.PROMISETYPE.EMPTY.EMPTY.EMPTY
	-> p2Terminate{p2State = END}
	-> P2();

P2ReceiveSign() = routerToP2?src.dest.msgtype.data1.data2.ct -> P2ReceiveSignAction(src, dest, msgtype, data1, data2, ct);

P2ReceiveSignAction(src, dest, msgtype, data1, data2, ct) =
	if(msgtype != SIGNTYPE || ct != CONTRACT || data1 == EMPTY || call(Pow, data1, P1PUBLIC) % P1MOD != CONTRACT)
	{	
		// send resolve2 if invalid sign received
		p2ToRouter!P2IP.TRUSTEDIP.RESOLVE2TYPE.p2Signature.p2RecPromise.CONTRACT
		// receive resolve2 confirmation from trusted party
		-> routerToP2?f1.f2.f3.f4.f5.f6
		// validate resolve2 confirmation
		-> P2ReceiveTrustedResolve2Confirmation(f1, f2, f3, f4, f5, f6)
	}
	else
	{
		p2StoreReceivedSign{p2RecSign = data1}
		-> tau{p2State=SENDSIGN}
		-> P2()
	};
	
P2ReceiveTrustedResolve2Confirmation(src, dest, msgtype, data1, data2, ct) =
	if(msgtype == ABORTCONFIRMATION)
	{
		resolve2Fail{p2State = END}
		-> P2()
	}
	else if(msgtype == RESOLVECONFIRMATION)
	{
		p2StoreResolve2Confirmation{p2TrustedConfirmation = data1}
		-> p2GetP1Sign{var p1PlusP2 = call(Pow, p2TrustedConfirmation, TRUSTPUBLIC) % TRUSTMOD; p2RecSign = p1PlusP2 - p2Signature}
		-> tau{p2State = END}
		-> P2()
	};

P2SendSign() = 
	p2ToRouter!P2IP.P1IP.SIGNTYPE.p2Signature.EMPTY.CONTRACT
	-> p2SendSign{p2State = END}
	-> P2()
	[]
	p2ToRouter!P2IP.P1IP.SIGNTYPE.EMPTY.EMPTY.EMPTY
	-> p2Terminate{p2State = END}
	-> P2();

// TrustedParty declarations
#define INIT 1;
#define ABORTED 2;
#define RESOLVED1 3;
#define RESOLVED2 4;

var trustedStatus = INIT;
var confirmation;
var generatedPrivate;
var generatedSignature;
var result;

TrustedParty() =
	routerToTrusted?src.dest.msgtype.data1.data2.ct -> TrustedPartyAction(src, dest, msgtype, data1, data2, ct);
	
TrustedPartyAction(src, dest, msgtype, data1, data2, ct)=
	if (msgtype == ABORTTYPE)
	{
		if (trustedStatus == INIT) 
		{
			setStatusAbort{trustedStatus = ABORTED}
			-> generateAbortConfirmation{confirmation = call(Pow, data1, TRUSTPRIVATE) % TRUSTMOD}
			-> trustedToRouter!TRUSTEDIP.src.ABORTCONFIRMATION.confirmation.EMPTY.EMPTY
			-> TrustedParty()
		}
		else if (trustedStatus == RESOLVE1TYPE || trustedStatus == RESOLVE2TYPE) 
		{
			trustedToRouter!TRUSTEDIP.src.RESOLVECONFIRMATION.EMPTY.EMPTY.EMPTY
			-> TrustedParty()
		}
	}
	else if(msgtype == RESOLVE2TYPE)
	{
		if (trustedStatus == INIT) 
		{
			setStatusResolved2{trustedStatus = RESOLVE2TYPE}
			-> generateP1Private{generatedPrivate = call(Pow, data2, TRUSTPRIVATE) % TRUSTMOD}
			-> generateP1Signature{generatedSignature = call(Pow, CONTRACT, generatedPrivate) % P1MOD}
			-> concatSignatures{result = generatedSignature + data1}
			-> generateResolve2Confirmation{confirmation = call(Pow, result, TRUSTPRIVATE) % TRUSTMOD}
			-> trustedToRouter!TRUSTEDIP.src.RESOLVECONFIRMATION.confirmation.EMPTY.EMPTY
			-> TrustedParty()
		}
		else if (trustedStatus == ABORTED) 
		{
			trustedToRouter!TRUSTEDIP.src.ABORTCONFIRMATION.EMPTY.EMPTY.EMPTY
			-> TrustedParty()
		}
	}
	else if(msgtype == RESOLVE1TYPE)
	{
		if (trustedStatus == INIT) 
		{
			setStatusResolved1{trustedStatus = RESOLVE1TYPE}
			-> generateP2Private{generatedPrivate=call(Pow,data2,TRUSTPRIVATE)%TRUSTMOD}
			-> generateP2Signature{generatedSignature=call(Pow,CONTRACT,generatedPrivate)%P2MOD}
			-> concatSignatures{result=generatedSignature+data1}
			-> generateResolved1Confirmation{confirmation=call(Pow,result,TRUSTPRIVATE)%TRUSTMOD}
			-> trustedToRouter!TRUSTEDIP.src.RESOLVECONFIRMATION.confirmation.EMPTY.EMPTY
			-> TrustedParty()
		}
		else if (trustedStatus==ABORTED) 
		{
			trustedToRouter!TRUSTEDIP.src.ABORTCONFIRMATION.EMPTY.EMPTY.EMPTY
			-> TrustedParty()
		}
	};
	

//Start of RouterSelector

#define GARBAGE -69;

RouterSelector() = 
	secureRouter{var dummy;} -> Router()
	[]
	attacker{var dummy;} -> Attacker();

//Router intialization
Router() =
	p1ToRouter?src.dest.msgtype.data1.data2.ct -> Forward(src, dest, msgtype, data1, data2, ct)
	[]
	p2ToRouter?src.dest.msgtype.data1.data2.ct -> Forward(src, dest, msgtype, data1, data2, ct)
	[]
	trustedToRouter?src.dest.msgtype.data1.data2.ct -> Forward(src, dest, msgtype, data1, data2, ct);


Forward(src, dest, msgtype, data1, data2, ct) =
	if (dest == P2IP)
	{
		routerToP2!src.dest.msgtype.data1.data2.ct
		-> Router()
	}
	else if (dest == P1IP)
	{
		routerToP1!src.dest.msgtype.data1.data2.ct
		-> Router()
	}
	else if (dest == TRUSTEDIP)
	{
		routerToTrusted!src.dest.msgtype.data1.data2.ct
		-> Router()
	} else {
		// TODO: Make the other processes do this too; if unrecognised then just ignore the input
		Router()
	};
	
Attacker() =
	p1ToRouter?src.dest.msgtype.data1.data2.ct -> AttackerForward(src, dest, msgtype, data1, data2, ct)
	[]
	p2ToRouter?src.dest.msgtype.data1.data2.ct -> AttackerForward(src, dest, msgtype, data1, data2, ct)
	[]
	trustedToRouter?src.dest.msgtype.data1.data2.ct -> AttackerForward(src, dest, msgtype, data1, data2, ct);


AttackerForward(src, dest, msgtype, data1, data2, ct) =
	if(dest == P2IP)
	{
		routerToP2!src.dest.msgtype.data1.data2.ct
		-> Attacker()
		[]
		routerToP2!GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE
		-> Attacker()
	} 
	else if (dest == P1IP)
	{
		routerToP1!src.dest.msgtype.data1.data2.ct
		-> Attacker()
		[]
		routerToP1!GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE
		-> Attacker()
	}
	else if(dest == TRUSTEDIP)
	{
		routerToTrusted!src.dest.msgtype.data1.data2.ct
		-> Attacker()
		[]
		routerToTrusted!GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE
		-> Attacker()
	} else {
		Attacker()
	};

System() = P1() ||| P2() ||| TrustedParty() ||| RouterSelector();

// Both processes eventually end
#define processesEnd p1State == END && p2State == END;
#assert System() reaches processesEnd;

// P1 only sends signature when it receives valid P2 promise
#define validPromise p1RecPromise == p2Promise;
#assert System() |= [](p1SendSign -> validPromise);

// If p1 sends signature, both parties will get signature
#define receiveSignature p1RecSign == p2Signature && p2RecSign == p1Signature;
#assert System() |= [](p1SendSign && secureRouter -> <>receiveSignature);

// If trusted party has once aborted, neither party will receive signature
#define trustedAborted trustedStatus == ABORTED;
#assert System() |= [](trustedAborted -> []!receiveSignature);

#assert System() deadlockfree;