#import "PAT.Math";

// State endcodings NOTE: Will not be used in channel encodings
#define GENERATE 0;
#define SENDPROMISE 1;
#define RECPROMISE 2;
#define SENDSIGN 3;
#define RECSIGN 4;
#define END 5;

// Contract ID
#define CONTRACT 11;

// P1 keys
#define P1PUBLIC 7;
#define P1PRIVATE 7;
#define P1MOD 21;

// P2 keys
#define P2PUBLIC 5;
#define P2PRIVATE 5;
#define P2MOD 14;

// Trusted party keys
#define TRUSTPUBLIC 3;
#define TRUSTPRIVATE 3;
#define TRUSTMOD 15;

	// Encoded data values
#define EMPTY -1;
	//Encoded message types
#define PROMISETYPE -2;
#define SIGNTYPE -3;
#define ABORTTYPE -4;
#define RESOLVE1TYPE -5;
#define RESOLVE2TYPE -6;
#define CONFIRMATIONTYPE -7;
#define ABORTEXISTTYPE -8;
#define RESOLVEEXISTTYPE -9;
	//Encoded Identities
#define P1IP 1;
#define P2IP 2;
#define TRUSTEDIP 3;

// StartStates
var p1State = GENERATE;
var p2State = GENERATE;

// P1
var p1RecPromise = EMPTY;
var p1RecSign = EMPTY;
var p1Promise;
var p1Signature;
var p1TrustedConfirmation=EMPTY;

// P2
var p2RecPromise = EMPTY;
var p2RecSignature = EMPTY;
var p2Promise;
var p2Signature;
var p2TrustedConfirmation=EMPTY;

// Channel declaration
channel p1ToRouter 10;
channel p2ToRouter 10;
channel routerToP1 10;
channel routerToP2 10;
channel trustedToRouter 10;
channel routerToTrusted 10;

//Message encoding style

// TODO: Put Contract in field4, always
// TODO: Write the format for TrustedParty originated messages

/*
	Msgtype:	Promise		Sign		Abort		Resolve1		Resolve2
	field 1:	Source IP(always)------------------------------------------------ 		
	field 2:	Dest Ip(always)--------------------------------------------------	
	field 3:	MSGTYPE(always)--------------------------------------------------
	field 4:	CONTRACT	SIGNATURE	P1PROMISE	P1SIGN			P2SIGN
	field 5:	PROMISE		EMPTY		EMPTY		p1RecPromise	p2RecPromise
	field 6:	EMPTY		EMPTY		CONTRACT	CONTRACT		CONTRACT
*/


//Start of P1

P1() =
	[p1State == GENERATE]P1GenerateValues()
	[]
	[p1State == SENDPROMISE]P1SendPromise()
	[]
	[p1State == RECPROMISE]P1ReceivePromise()
	[]
	[p1State == SENDSIGN]P1SendSign()
	[]
	[p1State == RECSIGN]P1ReceiveSign()
	[]
	[p1State == END]Skip;

P1GenerateValues() = 
	p1GeneratePromise{p1Promise = call(Pow, P1PRIVATE, TRUSTPUBLIC) % TRUSTMOD}
	-> p1GenerateSignature{p1Signature = call(Pow, CONTRACT, P1PRIVATE) % P1MOD}
	-> tau{p1State = SENDPROMISE}
	-> P1();
	
P1SendPromise() =
	p1ToRouter!P1IP.P2IP.PROMISETYPE.CONTRACT.p1Promise.EMPTY
	-> tau{p1State = RECPROMISE}
	-> P1()
	[]
	p1ToRouter!P1IP.P2IP.PROMISETYPE.EMPTY.EMPTY.EMPTY
	-> p1Terminate{p1State = END}
	-> P1();
	
P1ReceivePromise() = routerToP1?field1.field2.field3.field4.field5.field6 -> P1ReceivePromiseAction(field1, field2, field3, field4, field5, field6);

P1ReceivePromiseAction(field1, field2, field3, field4, field5, field6) =
	if (field3 != PROMISETYPE || field4 != CONTRACT || field4 == EMPTY || field5 == EMPTY)
	{
		// send abort if invalid promise received
		p1ToRouter!P1IP.TRUSTEDIP.ABORTTYPE.p1Promise.EMPTY.CONTRACT
		// receive abort confirmation from trusted party
		-> routerToP1?f1.f2.f3.f4.f5.f6
		// validate abort confirmation
		-> P1ReceiveTrustedAbortConfirmation(f1, f2, f3, f4, f5, f6)
	}
	else
	{
		p1StoreReceivedPromise{p1RecPromise=field5}
		-> tau{p1State = SENDSIGN}
		-> P1()
	};
	
P1ReceiveTrustedAbortConfirmation(field1, field2, field3, field4, field5, field6) =
	if (field3 == RESOLVEEXISTTYPE)
	{
		// TODO: Run assertion to check for P2SIGN
		p1AbortFail{p1State = END}
		-> P1()
	}
	else if (field3 == CONFIRMATIONTYPE)
	{
		// TODO: Why save field4?
		p1StoreAbortConfirmation{p1TrustedConfirmation = field4} 
		-> tau{p1State = END}
		-> P1()
	};
	
P1SendSign() =
	p1ToRouter!P1IP.P2IP.SIGNTYPE.p1Signature.EMPTY.EMPTY
	-> tau{p1State = RECSIGN}
	-> P1()
	[]
	p1ToRouter!P1IP.P2IP.SIGNTYPE.EMPTY.EMPTY.EMPTY
	-> p1Terminate{p1State=END}
	-> P1();

P1ReceiveSign() = routerToP1?field1.field2.field3.field4.field5.field6 -> P1ReceiveSignAction(field1, field2, field3, field4, field5, field6);

P1ReceiveSignAction(field1, field2, field3, field4, field5, field6)=
	if (field3 != SIGNTYPE || field4 == EMPTY || call(Pow, field4, P2PUBLIC) % P2MOD != CONTRACT)
	{
		// send resolve1 if invalid sign received
		p1ToRouter!P1IP.TRUSTEDIP.RESOLVE1TYPE.p1Signature.p1RecPromise.CONTRACT
		// receive resolve1 confirmation from trusted party
		-> routerToP1?f1.f2.f3.f4.f5.f6
		// validate resolve1 confirmation
		-> P1ReceiveTrustedResolve1Confirmation(f1, f2, f3, f4, f5, f6)
	}
	else
	{
		p1StoreReceivedSign{p1RecSign = field4}
		-> tau{p1State = END}
		-> P1()
	};
	
P1ReceiveTrustedResolve1Confirmation(field1, field2, field3, field4, field5, field6) =
	if (field3 == ABORTEXISTTYPE)
	{
		// TODO: Run assertion here?
		resolve1Fail{p1State = END}
		-> P1()
	}
	else if (field3 == CONFIRMATIONTYPE)
	{
		p1StoreResolve1Confirmation{p1TrustedConfirmation = field4}
		-> p1GetP2Sign{var p1PlusP2 = call(Pow, p1TrustedConfirmation, TRUSTPUBLIC) % TRUSTMOD; p1RecSign = p1PlusP2 - p1Signature}
		-> tau{p1State = END}
		-> P1()
	};


//Start of P2
	
P2() = 
	[p2State == GENERATE]P2GenerateValues()
	[]
	[p2State == RECPROMISE]P2ReceivePromise()
	[]
	[p2State == SENDPROMISE]P2SendPromise()
	[]
	[p2State == RECSIGN]P2ReceiveSign()
	[]
	[p2State == SENDSIGN]P2SendSign()
	[]
	[p2State == END]Skip;

P2GenerateValues() =
	p2GeneratePromise{p2Promise = call(Pow,P2PRIVATE,TRUSTPUBLIC) % TRUSTMOD}
	-> p2GenerateSignature{p2Signature = call(Pow,CONTRACT,P2PRIVATE) % P2MOD}
	-> tau{p2State = RECPROMISE}
	-> P2();
	
P2ReceivePromise() = routerToP2?field1.field2.field3.field4.field5.field6 -> P2ReceivePromiseAction(field1, field2, field3, field4, field5, field6);

P2ReceivePromiseAction(field1, field2, field3, field4, field5, field6) =
	if(field3 != PROMISETYPE || field4 != CONTRACT || field4 == EMPTY || field5 == EMPTY)
	{
		p2Terminate{p2State = END}
		-> P2()
	}
	else
	{
		p2StoreReceivedPromise{p2RecPromise = field5}
		-> tau{p2State = SENDPROMISE}
		-> P2()
	};
	
P2SendPromise() = 
	p2ToRouter!P2IP.P1IP.PROMISETYPE.CONTRACT.p2Promise.EMPTY
	-> tau{p2State = RECSIGN}
	-> P2()
	[]
	p2ToRouter!P2IP.P1IP.PROMISETYPE.EMPTY.EMPTY.EMPTY
	-> p2Terminate{p2State = END}
	-> P2();

P2ReceiveSign() = routerToP2?field1.field2.field3.field4.field5.field6 -> P2ReceiveSignAction(field1, field2, field3, field4, field5, field6);

P2ReceiveSignAction(field1, field2, field3, field4, field5, field6) =
	if(field3 != SIGNTYPE || field4 == EMPTY || call(Pow, field4, P1PUBLIC) % P1MOD != CONTRACT)
	{	
		// send resolve2 if invalid sign received
		p2ToRouter!P2IP.TRUSTEDIP.RESOLVE2TYPE.p2Signature.p2RecPromise.CONTRACT
		// receive resolve2 confirmation from trusted party
		-> routerToP2?f1.f2.f3.f4.f5.f6
		// validate resolve2 confirmation
		-> P2ReceiveTrustedResolve2Confirmation(f1, f2, f3, f4, f5, f6)
	}
	else
	{
		p2StoreReceivedSign{p2RecSignature = field4}
		-> tau{p2State=SENDSIGN}
		-> P2()
	};
	
P2ReceiveTrustedResolve2Confirmation(field1, field2, field3, field4, field5, field6) =
	if(field3 == ABORTEXISTTYPE)
	{
		resolve2Fail{p2State = END}
		-> P2()
	}
	else if(field3 == CONFIRMATIONTYPE)
	{
		p2StoreResolve2Confirmation{p2TrustedConfirmation = field4}
		-> p2GetP1Sign{var p1PlusP2 = call(Pow, p2TrustedConfirmation, TRUSTPUBLIC) % TRUSTMOD; p2RecSignature= p1PlusP2 - p2Signature}
		-> tau{p2State = END}
		-> P2()
	};

P2SendSign() = 
	p2ToRouter!P2IP.P1IP.SIGNTYPE.p2Signature.EMPTY.EMPTY
	-> tau{p2State = END}
	-> P2()
	[]
	p2ToRouter!P2IP.P1IP.SIGNTYPE.EMPTY.EMPTY.EMPTY
	-> p2Terminate{p2State = END}
	-> P2();

// TrustedParty declarations
#define INIT 1;
#define ABORTED 2;
#define RESOLVED1 3;
#define RESOLVED2 4;

var trustedStatus = INIT;
var confirmation;
var generatedPrivate;
var generatedSignature;
var result;

TrustedParty() =
	routerToTrusted?field1.field2.field3.field4.field5.field6 -> TrustedPartyAction(field1, field2, field3, field4, field5, field6);
	
TrustedPartyAction(field1, field2, field3, field4, field5, field6)=
	if (field3 == ABORTTYPE)
	{
		if (trustedStatus == INIT) 
		{
			setStatusAbort{trustedStatus = ABORTED}
			-> generateAbortConfirmation{confirmation = call(Pow, field4, TRUSTPRIVATE) % TRUSTMOD}
			-> trustedToRouter!TRUSTEDIP.field1.CONFIRMATIONTYPE.confirmation.EMPTY.EMPTY
			-> TrustedParty()
		}
		else if (trustedStatus == RESOLVE1TYPE || trustedStatus == RESOLVE2TYPE) 
		{
			trustedToRouter!TRUSTEDIP.field1.RESOLVEEXISTTYPE.EMPTY.EMPTY.EMPTY
			-> TrustedParty()
		}
	}
	else if(field3 == RESOLVE2TYPE)
	{
		if (trustedStatus == INIT) 
		{
			setStatusResolved2{trustedStatus = RESOLVE2TYPE}
			-> generateP1Private{generatedPrivate = call(Pow, field5, TRUSTPRIVATE) % TRUSTMOD}
			-> generateP1Signature{generatedSignature = call(Pow, CONTRACT, generatedPrivate) % P1MOD}
			-> concatSignatures{result = generatedSignature + field4}
			-> generateResolve2Confirmation{confirmation = call(Pow, result, TRUSTPRIVATE) % TRUSTMOD}
			-> trustedToRouter!TRUSTEDIP.field1.CONFIRMATIONTYPE.confirmation.EMPTY.EMPTY
			-> TrustedParty()
		}
		else if (trustedStatus == ABORTED) 
		{
			trustedToRouter!TRUSTEDIP.field1.ABORTEXISTTYPE.EMPTY.EMPTY.EMPTY
			-> TrustedParty()
		}
	}
	else if(field3 == RESOLVE1TYPE)
	{
		if (trustedStatus == INIT) 
		{
			setStatusResolved1{trustedStatus = RESOLVE1TYPE}
			-> generateP2Private{generatedPrivate=call(Pow,field5,TRUSTPRIVATE)%TRUSTMOD}
			-> generateP2Signature{generatedSignature=call(Pow,CONTRACT,generatedPrivate)%P2MOD}
			-> concatSignatures{result=generatedSignature+field4}
			-> generateResolved1Confirmation{confirmation=call(Pow,result,TRUSTPRIVATE)%TRUSTMOD}
			-> trustedToRouter!TRUSTEDIP.field1.CONFIRMATIONTYPE.confirmation.EMPTY.EMPTY
			-> TrustedParty()
		}
		else if (trustedStatus==ABORTED) 
		{
			trustedToRouter!TRUSTEDIP.field1.ABORTEXISTTYPE.EMPTY.EMPTY.EMPTY
			-> TrustedParty()
		}
	};
	

//Start of RouterSelector

#define GARBAGE -69;

RouterSelector() = 
	secureRouter{var dummy;} -> Router()
	[]
	attacker{var dummy;} -> Attacker();

//Router intialization
Router() =
	p1ToRouter?field1.field2.field3.field4.field5.field6 -> Forward(field1, field2, field3, field4, field5, field6)
	[]
	p2ToRouter?field1.field2.field3.field4.field5.field6 -> Forward(field1, field2, field3, field4, field5, field6)
	[]
	trustedToRouter?field1.field2.field3.field4.field5.field6 -> Forward(field1, field2, field3, field4, field5, field6);


Forward(field1, field2, field3, field4, field5, field6) =
	if (field2 == P2IP)
	{
		routerToP2!field1.field2.field3.field4.field5.field6
		-> Router()
	}
	else if (field2 == P1IP)
	{
		routerToP1!field1.field2.field3.field4.field5.field6
		-> Router()
	}
	else if (field2 == TRUSTEDIP)
	{
		routerToTrusted!field1.field2.field3.field4.field5.field6
		-> Router()
	} else {
		// TODO: Make the other processes do this too; if unrecognised then just ignore the input
		Router()
	};
	
Attacker() =
	p1ToRouter?field1.field2.field3.field4.field5.field6 -> AttackerForward(field1, field2, field3, field4, field5, field6)
	[]
	p2ToRouter?field1.field2.field3.field4.field5.field6 -> AttackerForward(field1, field2, field3, field4, field5, field6)
	[]
	trustedToRouter?field1.field2.field3.field4.field5.field6 -> AttackerForward(field1, field2, field3, field4, field5, field6);


AttackerForward(field1, field2, field3, field4, field5, field6) =
	if(field2 == P2IP)
	{
		routerToP2!field1.field2.field3.field4.field5.field6
		-> Attacker()
		[]
		routerToP2!GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE
		-> Attacker()
	} 
	else if (field2 == P1IP)
	{
		routerToP1!field1.field2.field3.field4.field5.field6
		-> Attacker()
		[]
		routerToP1!GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE
		-> Attacker()
	}
	else if(field2 == TRUSTEDIP)
	{
		routerToTrusted!field1.field2.field3.field4.field5.field6
		-> Attacker()
		[]
		routerToTrusted!GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE.GARBAGE
		-> Attacker()
	} else {
		Attacker()
	};

System() = P1() ||| P2() ||| TrustedParty() ||| RouterSelector();

#assert System deadlockfree;